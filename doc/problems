1. 在对泛型函数体进行verify时, 一些verify阶段保留的信息在execute阶段会失效
	问题:
		为了verify泛型函数的定义, 一开始的方法是构造一些虚拟的类型, 将约束内容添加到这些类型中, 使之满足约束限定.
		然后用这些虚拟类型来verify泛型函数的body, 将verify的结果暂存用于execute 
		看着似乎没什么问题. 

		后来加入了对类型属性访问的语法, 在verify这种语法时, 会将属性名转换为attribute列表中的index. 在execute阶段使用该index来访问属性.
		这对于普通函数没啥问题. 但是对于泛型函数就有大问题了. 虚拟类型和实际类型的属性列表可能不同, 导致verify得到的attribute-index是错的

		为了解决这个问题, 将attribute-index修改为一个组合: constraint的类型id 以及该constraint下的方法index.
		但是这种方法依然不行. 因为虚拟类型生成的constraint的类型id和实际类型生成的类型id是不同的, 运行时会找不到对应constraint

	分析:
		看起来单纯的用虚拟泛参verify泛型函数的定义是不够的. 需要在泛型函数调用的时候也要做一些处理. 
		假如在泛型函数调用的时候直接以实际泛参来verify泛型函数那? 这样应该是可以解决, 但是这样处理就和隐式声明约束(比如C++中的模板)一样了. 
		我还是期望能够将泛型函数定义的verify独立出来. 在泛型函数调用的时候只需要校验实际泛参是否满足约束.

		另外还引出了以下几个问题:
			为什么要将verify阶段的信息保留给execute阶段? 要保留哪些信息?

	解决:
		目前解决办法: 
			在泛型函数实例化时, 通过深拷贝得到函数ast子树的副本, 该副本针对实例化的类型进行verify. 这样就和函数调用时的类型对应上了. 不会出错
		该解决办法的缺陷:
			每次实例化都需要克隆一个副本. 代码会膨胀.
			每次实例化都需要verify一遍副本的函数体. 明明已经使用虚拟的泛参进行了verify. 这个缺陷不能接受!
				但是对泛型函数实例再次verify也是有好处的, 可以在这里做compile-time compute. 比如代码中的一些false分支可以优化掉

2. 为什么要将verify阶段的信息保留给execute阶段? 要保留哪些信息?
	需要明确定义verify阶段的处理内容:
		语法检查
		类型检查 
		类型推导, 重载函数选择
		泛型实例化 
		编译期计算
		编译期优化
