1. 泛型函数定义的verify时, method_index错误
	问题:
		为了verify泛型函数的定义, 一开始的方法是构造一些虚拟的类型, 将约束内容添加到这些类型中, 使之满足约束限定.
		然后用这些虚拟类型来verify泛型函数的body, 将verify的结果暂存用户execute 
		看着似乎没什么问题. 

		后来加入了对类型属性访问的语法, 在verify这种语法时, 会将属性名转换为attribute列表中的index. 在execute阶段使用该index来访问属性.
		这对于普通函数没啥问题. 但是对于泛型函数就有大问题了. 虚拟类型和实际类型的属性列表可能不同, 导致verify得到的attribute-index是错的

		为了解决这个问题, 将attribute-index修改为一个组合: constraint的类型id 以及该constraint下的方法index.
		但是这种方法依然不行. 因为虚拟类型生成的constraint的类型id和实际类型生成的类型id是不同的, 运行时会找不到对应constraint

	分析:
		看起来单纯的用虚拟泛参verify泛型函数的定义是不够的. 需要在泛型函数调用的时候也要做一些处理. 
		假如在泛型函数调用的时候直接以实际泛参来verify泛型函数那? 这样应该是可以解决, 但是这样处理就和隐式声明约束(比如C++中的模板)一样了. 
		我还是期望能够将泛型函数定义的verify独立出来. 在泛型函数调用的时候只需要校验实际泛参是否满足约束.

		另外还引出了以下几个问题:
			为什么要将verify阶段的信息保留给execute阶段? 要保留哪些信息?

	解决:

2. 为什么要将verify阶段的信息保留给execute阶段? 要保留哪些信息?
