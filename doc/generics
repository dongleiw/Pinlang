1. 什么是泛型? 为什么需要泛型?
	泛型字面意思就是泛化的类型. 一般的逻辑(函数/方法)是和具体类型绑定的, 这种函数(方法)只能接受明确的类型. 但是一些逻辑可以作用于多种类型, 只要类型满足某些约束条件. 
	比如以下两个函数. 逻辑都是求两个参数的和. 
		fn sum(a int, b int) int{ return a+b; }
		fn sum(a float, b float) float{ return a+b; }

		这两个函数可以用以下伪码描述:
			泛型参数:
				T T是int or T是float
			函数体:
				fn sum(a T, b T) T{
					return a+b; 
				}

			其中T是泛型参数(简称为泛参), 泛型函数可以看作是一个接受类型作为参数的函数, 根据具体的参数来生成实际函数的过程称为泛型函数的实例化. 
		

	泛型的实现方式选择
		从上面例中中可以看出, 泛型的构建依赖于一个更基础的概念"对类型的约束", 也就是类型需要满足的条件. 泛型通过约束来限定可接受的类型集合
		那么如何描述"对类型的约束"哪? 不同语言选择了不同的方式.
			隐式声明约束:
				比如C++中的template, 无需显示定义约束条件. 所有约束由编译器自动推导. 坏处是编译耗时长, 错误提示不友好, 不够直观
				(C++20引入了concept, 是一种显式声明的方式) 
			显示定义约束, 隐式声明约束(duck type):
				比如Golang中的interface. 需要显式定义. 但是只要类型实现了interface的相关接口, 就会自动满足了interface的限定. 
				(Golang没有泛型, 这是一个不严谨的例子)
			显式定义约束, 显式声明约束:
				比如Rust中的trait. 需要显式定义约束(Rust中为类型的特性), 同时需要使用impl显式声明实现某个约束. 可以在定义时进行类型检测, 错误提示更友好, 比较直观
				我们选择这种方式
			
	泛型的符号选择
		<>
			fn sum<T Add<T,T>>(a T, b T) T{
				return a+b;
			}
			sum<int>(1,2);

		turborfish
			Add::<int,int>
			sum::<int>

		[] (目前是选择的这个)
			fn sum[T Add[T,T]](a T, b T) T{
				return a+b;
			}
			sum[int](1,2);

			数组下标访问则改为()
				var array = {1,2,3};
				array(0)
				array(1)
			

2. 约束(constraint)
	constraint(约束)是类型的限定条件的集合. 限定方式包括
		* 提供的接口 ( 目前只考虑这一点 )
			{ T | T必须有接口'add(int)'. T必须有接口'GetId()int'.  }
		* 类型大小
		* 类型名
		* 提供的字段属性
	
	多个constraint的相同方法的冲突问题
		在引入constraint之前, 类型的方法是平面的, 所有方法都处于相同层级. 名称相同参数不同的方法构成重载. 名字相同参数相同的方法构成冲突
		但是在引入constraint之后, 方法有了层级:
			一种是不属于任何constraint的方法
			一种是为了实现constraint而引入的方法.
		这种情况下, 函数重载和冲突逻辑如何判定? 不同constraint的相同函数如何处理? 判定为冲突, 还是允许存在?

		
	约束和类型的关系:
		类型是对值的限定. 
			比如值'1'是int类型, 那么'1'大小为4byte, 有方法add/sub/mul/div/mod等方法
		约束是对类型的限定. 
			比如类型'T'满足约束Add, 那么'T'有方法: 'add(int)int'

	定义约束
		// 定义约束
		constraint AddInt{
			fn add(another int);
		}
		// 定义泛型约束
		constraint Add[ AnotherT, ReturnT ]{
			fn add(another AnotherT) ReturnT;
		}
		
	内置类型自动实现一些预定义的constraint
		int: Add Sub Mul Div Mod Strinfiy
		float: Add Sub Mul Div Strinfiy
		str: Add Strinfiy
		bool: Strinfiy

	问题:
		是否支持字段属性限定?
		是否支持编译期常量表达式限定?
		是否支持默认函数实现?
		约束如何复用(继承?)
		要不要支持给第三方库添加constraint?
		如何实现constraint?


3. 泛型函数
	在约束的基础上, 就可以实现泛型函数了. 
	定义泛型函数:
		fn sum[T Add[T,T]] (a T, b T) T { return a+b; }

		
4. 将泛型函数和函数重载结合起来的一个方案
	当同时有函数重载, 泛型函数, 缺省参数的时候, candidate的选择规则比较复杂. 如果简单的选择"不支持函数重载", 可以解决问题, 但是也失去了"函数重载"带来的一些便利性
	方案要求: 
		* 避免复杂的选择candidate的规则, 更加直观, 实现简单
		* 尽可能整合泛型函数和函数重载的优秀的地方

	// 普通函数的简单定义
	fn foo(){}
	
	// 泛型函数的简单定义
	fn foo[T Add[T,T]](a T, b T){}
	
	// 如果有多个参数个数相同的实现, 必须都是非泛型实现, 且参数类型不同
	fn foo{
		(a int){}
		(a str){}
	}
	fn foo{
		(a int){}
		(a str){}
		[T Stringify](a T){} // 有歧义. int/str可能满足Stringify的限制
	}
	fn foo{
		[T Stringify](a T){} 
		[T Printable](a T){} // 有歧义. 类型可能同时满足Stringify和Printable的限制
	}
	fn foo{
		[T Stringify](a T, b int){} 
		[T Printable](a T, b str){} // 有歧义. 类型可能同时满足Stringify和Printable的限制
	}
	fn foo{
		[T Stringify](a T){} 
		[T Printable](a T, b T){} // 没有歧义, 参数个数不同, 可以区分. (如果支持缺省参数, 那就有歧义了)
	}
	fn printf{
		[T ToString](fmt str){} 
		[T ToString](fmt str, a1 T){} 
		[T ToString](fmt str, a1 T, a2 T){} 
		[T ToString](fmt str, a1 T, a2 T, a3 T){} 
		[T ToString](fmt str, a1 T, a2 T, a3 T, a4 T){} 
		[T ToString](fmt str, a1 T, a2 T, a3 T, a4 T, a5 T){} 
		[T ToString](fmt str, a1 T, a2 T, a3 T, a4 T, a5 T, a6 T){} 
		[T ToString](fmt str, a1 T, a2 T, a3 T, a4 T, a5 T, a6 T, a7 T){} 
		[T ToString](fmt str, a1 T, a2 T, a3 T, a4 T, a5 T, a6 T, a7 T, a8 T){} 
		[T ToString](fmt str, a1 T, a2 T, a3 T, a4 T, a5 T, a6 T, a7 T, a8 T, a9 T){} 
		[T ToString](fmt str, a1 T, a2 T, a3 T, a4 T, a5 T, a6 T, a7 T, a8 T, a9 T, a10 T){} 
		[T ToString](fmt str, a1 T, a2 T, a3 T, a4 T, a5 T, a6 T, a7 T, a8 T, a9 T, a10 T, a11 T){} 
		[T ToString](fmt str, a1 T, a2 T, a3 T, a4 T, a5 T, a6 T, a7 T, a8 T, a9 T, a10 T, a11 T, a12 T){} 
		[T ToString](fmt str, a1 T, a2 T, a3 T, a4 T, a5 T, a6 T, a7 T, a8 T, a9 T, a10 T, a11 T, a12 T, a13 T){} 
		[T ToString](fmt str, a1 T, a2 T, a3 T, a4 T, a5 T, a6 T, a7 T, a8 T, a9 T, a10 T, a11 T, a12 T, a13 T, a14 T){} 
	}
	
	// 泛参的限制条件可以是具体类型, 也可以是约束
	fn foo{
		[T int || str || Stringify](a T){}
		[T int || (Printable && Stringify)](a T){}
	}
