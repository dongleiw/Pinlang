######
1. 什么是泛型? 为什么需要泛型?
	泛型字面意思就是泛化的类型. 一般的逻辑(函数/方法)是和具体类型绑定的, 这种函数(方法)只能接受明确的类型. 但是一些逻辑可以作用于多种类型, 只要类型满足某些约束条件. 
	比如以下两个函数. 逻辑都是求两个参数的和. 
		fn sum(a int, b int) int{ return a+b; }
		fn sum(a float, b float) float{ return a+b; }

		这两个函数可以简化为以下方式:
			fn sum [ T {T是int 或者T是float} ]  (a T, b T) T { return a+b; }
		

	泛型的实现方式选择
		从上面例中中可以看出, 泛型的构建依赖于一个更基础的概念"对类型的约束", 也就是类型需要满足的条件. 泛型通过约束来限定可接受的类型集合
		那么如何描述"对类型的约束"哪? 不同语言选择了不同的方式.
			隐式声明约束:
				比如C++中的template, 无需显示定义约束条件. 所有约束由编译器自动推导. 坏处是编译耗时长, 错误提示不友好, 不够直观
				(C++20引入了concept, 是一种显式声明的方式) 
			显示定义约束, 隐式声明约束(duck type):
				比如Golang中的interface. 需要显式定义. 但是只要类型实现了interface的相关接口, 就会自动满足了interface的限定. 
				(Golang没有泛型, 这是一个不严谨的例子)
			显式定义约束, 显式声明约束:
				比如Rust中的trait. 需要显式定义约束(Rust中为类型的特性), 同时需要使用impl显式声明实现某个约束. 可以在定义时进行类型检测, 错误提示更友好, 比较直观
				我们选择这种方式
			

2. 约束(constraint)
	constraint(约束)是类型的限定条件的集合. 限定方式包括
		* 提供的接口 ( 目前只考虑这一点 )
			{ T | T必须有接口'add(int)'. T必须有接口'GetId()int'.  }
		* 类型大小
		* 类型名
		* 提供的字段属性
	
	约束和类型的关系:
		类型是对值的限定. 
			比如值'1'是int类型, 那么'1'大小为4byte, 有方法add/sub/mul/div/mod等方法
		约束是对类型的限定. 
			比如类型'T'满足约束Add, 那么'T'有方法: 'add(int)int'

	定义约束
		// 定义约束
		constraint AddInt{
			fn add(another int);
		}
		// 定义泛型约束
		constraint Add[ AnotherT, ReturnT ]{
			fn add(another AnotherT) ReturnT;
		}
		
	内置类型自动实现一些预定义的restriction
		int: Add Sub Mul Div Mod Strinfiy
		float: Add Sub Mul Div Strinfiy
		str: Add Strinfiy
		bool: Strinfiy

	问题:
		是否支持字段属性? 
		是否支持默认函数实现?
		如何处理多个restriction的相同方法的冲突问题?
		约束如何复用(继承?)
		要不要支持给第三方库添加restriction?
		如何实现restriction?


3. 泛型函数
	在约束的基础上, 就可以实现泛型函数了. 
	定义泛型函数:
		fn sum[T Add[T,T]] (a T, b T) T { return a+b; }

		
