类型

分类:
	内置基础类型
		type
		i32
		i64
		float
		str
		bool
	基础类型组合得到的复合类型
		class
		tuple
		array
	值类型和引用类型
		值类型(value type):
			type, i32, i64, float, bool, array
		引用类型(reference type):
			str class tuple
		区别:
			值类型的变量的内容为值, 而引用类型的值是一个指向真正的数据内存地址的指针
			赋值区别:
				a = b;
				假如a/b是值类型, 那么a会得到b的值的一份拷贝(数据相同, 内存地址不同)
				假如a/b是引用类型, 那么a会指向b指向的数据(内存地址相同, 数据自然也相同)
				值类型的变量在赋值时, 目标变量获得到源变量的值的一份拷贝. 而引用类型的变量在赋值时, 目标
			将一个类型定义为值类型还是引用类型的依据是什么? 为什么不都设置为值类型(引用类型)?

	数组类型:
		[N]T: N为编译期常量. T为任意类型
		*[N]T: N为编译期常量. T为任意类型. 指向[N]T的指针
		*T: T为任意类型. 指向T的指针. 指向的数据可能是一个T, 也可能是多个T组成的数组

		例子:
			p的类型为*T
			p[0] == *(p+0) = *p

		例子:
			var a = [2]i32{1,2};
			var pe = &(a[0]); //  获取第0元素的地址 *i32
			var pa = &a; // 类型为*[2]i32. 指向数组的指针

			a[0] // 获取第0元素的值 i32
			&a   // 获取数组的地址 *[2]i32
			&(a[0]) // 获取第0元素的地址 *i32

			*pe   // 第0元素的值 i32
			pe[0] // 第0元素的值 i32
			*(pe+0) // 第0元素的值 i32

			pa[0] // 数组a  [2]i32
			pa[1] // 并不是a, 而是a后面的数组 [2]i32
			*pa   // 数组a  [2]i32

		例子:
			var a = [2]i32{1,2};
			var b = a; // 数组的赋值操作. 会拷贝一份a给b

			fn foo(arg [2]i32){}
			foo(a); // 数组的赋值操作. 会拷贝一份a作为参数

			fn foo(arg &[2]i32){}
			foo(a); // 参数是引用类型. 不拷贝数组数据

			fn foo(arg *[2]i32){}
			foo(&a); // 参数是指向数组的指针类型. 不拷贝数组数据

			fn foo(arg *i32){}
			foo(&(a[0])); // 参数是指向数组元素的指针类型. 不拷贝数组数据

	指针类型
		*T 其中T是任意类型. 值为一个内存地址, 该内存地址中存放了一个类型为T的值
	
		例子:
			- *i32 内存地址中存放了一个类型为i32的值
			- *[3]i32 内存地址中存放了一个类型为[3]i32的值
			- **i32 内存地址中存放了一个类型为*i32的值
			- null 常量, 空指针. T为任意类型
				
		*T 和乘积的语义冲突问题:
			var a *T = &b;
			var b = i*j;

		指针运算:

特殊类型type:
	将类型当作值(该值的类型是type)
		比如int是一个variable, 类型是type, 值是TYPE_ID_INT
	将类型视作值后, 类型本身也可以参与运算, 进行传递, 比如:
		1. 类型别名
			const StudentId = int;
			StudentId是一个类型, 该类型的值是int. 


各类型的默认值:
	type	none
	i32		0
	i64		0
	float	0.0
	bool	false
	str		""
	[]T		[]T{}

各类型的内存大小:
	type	4
	i32		4
	int		4
	i64		8
	float	4
	bool	1
	str		8 (pointer)
	[]T		8 (pointer)
	class	8 (pointer)
